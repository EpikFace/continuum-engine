import { IncrementalEngine } from './engine.js';

const engine = new IncrementalEngine();

/**
 * This method is called for each 'tick' or cycle generated by requestAnimationFrame
 * @param {} dt 
 */
const onTick = (dt) => {
    engine.onTick(dt);
    updateUI();
    window.requestAnimationFrame(onTick);
}

// DOM elements
const statusDiv = document.getElementById("content");
let buttons = {}

function updateUI() {
    let text = `<h2>Currency</h2>Gold: ${engine.currency("gold").value}<h1>Entities:</h1>`;

    for (let e in engine.entities) {
        let entity = engine.entities[e];
        text += `${e} (${engine.formatNumber(entity.incrementBy)}/${entity.incrementAfter}ms): ${engine.formatNumber(entity.count)} (${entity.count})<br>`;
    }

    statusDiv.innerHTML = text;
}

// start the timer using animation frame
window.onload = function() {
    createCurrencies();
    createEntities();
    connectUItoHandlers();

    console.log("%cIncremental Engine loaded and initialised", "color: blue");
    window.requestAnimationFrame(onTick);
};

function createCurrencies() {
    engine.createCurrency("gold", 0);
}

function createEntities() {
    engine.createEntity("Source Code", 1000, 1).setCustomProcessor(function(dt) {
        let incrementBy = (this.incrementBy * Math.trunc((dt-this.lastProcessed)/this.incrementAfter));
        this.count += incrementBy;
        this.engine.currency("gold").incrementBy(this.incrementBy);
    });
    engine.createEntity("Graphics", 0, 1);
    engine.createEntity("Sound", 0, 1);
    engine.createEntity("Text", 0, 1);
    engine.createEntity("Translations", 0, 0.1)
        .setCustomProcessor(function (dt) {
        let incrementBy = (this.incrementBy * Math.trunc((dt-this.lastProcessed)/this.incrementAfter));
        this.count += incrementBy;
        if (this.count > this.maxCount) this.count = this.maxCount;
    });
}

function connectUItoHandlers() {
    buttons = {
        "formatScientific": document.getElementById("formatScientific"),
        "formatDictionary": document.getElementById("formatDictionary"),
        "formatAbstract": document.getElementById("formatAbstract"),
        "Source Code": {
            "Buy1": document.getElementById("BuySCx1"),
            "+": document.getElementById("SC+"),
            "-": document.getElementById("SC-")
        },
        "Graphics": {
            "+": document.getElementById("Graphics+"),
            "-": document.getElementById("Graphics-")
        },
        "Sound": {
            "+": document.getElementById("Sound+"),
            "-": document.getElementById("Sound-")
        },
        "Text": {
            "+": document.getElementById("Text+"),
            "-": document.getElementById("Text-")
        },
        "Translations": {
            "+": document.getElementById("Translations+"),
            "-": document.getElementById("Translations-")
        }
    };

    // formatter buttons
    buttons.formatScientific.addEventListener("click", (e) => { engine.setNumberFormatter("scientific") });
    buttons.formatDictionary.addEventListener("click", (e) => { engine.setNumberFormatter("dictionary") });
    buttons.formatAbstract.addEventListener("click", (e) => { engine.setNumberFormatter("abstract") });

    // game and dev control buttons
    for (let key of ["Source Code", "Graphics", "Sound", "Text", "Translations"]) {
        if (buttons[key]["Buy1"]) {
            buttons[key]["Buy1"].addEventListener("click", (e) => {
                const baseCost = parseFloat(e.target.dataset.basecost);
                const cost = Math.round(parseFloat(e.target.dataset.cost));
                const entity = e.target.dataset.entity;
                if (engine.currency("gold").value - cost >= 0) {
                    engine.currency("gold").incrementBy(-cost);
                    engine.entities[entity].incrementBy += 1;
                    e.target.dataset.cost = Math.round(baseCost * Math.pow(1.1, engine.entities[entity].incrementBy));
                    e.target.innerHTML = `Buy 1 @ ${e.target.dataset.cost} gold`;
                }
            });
        }
        buttons[key]["+"].addEventListener("click", (e) => {
            const entity = e.target.dataset.entity;
            engine.entities[entity].incrementBy += parseFloat(e.target.dataset.incrementby);
        });
        buttons[key]["-"].addEventListener("click", (e) => {
            const entity = e.target.dataset.entity;
            engine.entities[entity].incrementBy += parseFloat(e.target.dataset.incrementby);
            if ( engine.entities[entity].incrementBy < 0 ) {
                engine.entities[entity].incrementBy = 0;
            }
        });
    }
}